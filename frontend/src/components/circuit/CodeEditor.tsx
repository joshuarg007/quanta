import { useMemo } from 'react';
import { useCircuit } from '../../stores/circuitStore';
import type { Gate } from '../../types/quantum';
import './CodeEditor.css';

// Generate Qiskit Python code from circuit
function generateQiskitCode(numQubits: number, gates: Gate[]): string {
  const lines: string[] = [
    '# Generated by QUANTA',
    'from qiskit import QuantumCircuit, Aer, execute',
    'from qiskit.visualization import plot_histogram',
    '',
    `# Create a quantum circuit with ${numQubits} qubits`,
    `qc = QuantumCircuit(${numQubits}, ${numQubits})`,
    '',
  ];

  // Sort gates by step
  const sortedGates = [...gates].sort((a, b) => a.step - b.step);

  // Group by step
  const stepGroups = new Map<number, Gate[]>();
  sortedGates.forEach((gate) => {
    const existing = stepGroups.get(gate.step) || [];
    existing.push(gate);
    stepGroups.set(gate.step, existing);
  });

  // Generate code for each step
  Array.from(stepGroups.entries())
    .sort(([a], [b]) => a - b)
    .forEach(([step, gatesInStep]) => {
      lines.push(`# Step ${step}`);
      gatesInStep.forEach((gate) => {
        lines.push(gateToQiskit(gate));
      });
      lines.push('');
    });

  // Add measurement and execution
  if (gates.length > 0) {
    lines.push('# Measure all qubits');
    lines.push(`qc.measure(range(${numQubits}), range(${numQubits}))`);
    lines.push('');
    lines.push('# Simulate the circuit');
    lines.push("simulator = Aer.get_backend('qasm_simulator')");
    lines.push('job = execute(qc, simulator, shots=1024)');
    lines.push('result = job.result()');
    lines.push('counts = result.get_counts(qc)');
    lines.push('');
    lines.push('# Display results');
    lines.push('print(counts)');
    lines.push('plot_histogram(counts)');
  }

  return lines.join('\n');
}

function gateToQiskit(gate: Gate): string {
  switch (gate.type) {
    case 'H':
      return `qc.h(${gate.qubit})`;
    case 'X':
      return `qc.x(${gate.qubit})`;
    case 'Y':
      return `qc.y(${gate.qubit})`;
    case 'Z':
      return `qc.z(${gate.qubit})`;
    case 'S':
      return `qc.s(${gate.qubit})`;
    case 'T':
      return `qc.t(${gate.qubit})`;
    case 'RX':
      return `qc.rx(${gate.parameter ?? Math.PI / 4}, ${gate.qubit})`;
    case 'RY':
      return `qc.ry(${gate.parameter ?? Math.PI / 4}, ${gate.qubit})`;
    case 'RZ':
      return `qc.rz(${gate.parameter ?? Math.PI / 4}, ${gate.qubit})`;
    case 'CNOT':
      return `qc.cx(${gate.controlQubit ?? 0}, ${gate.qubit})`;
    case 'CZ':
      return `qc.cz(${gate.controlQubit ?? 0}, ${gate.qubit})`;
    case 'SWAP':
      return `qc.swap(${gate.qubit}, ${gate.controlQubit ?? gate.qubit + 1})`;
    case 'TOFFOLI':
      return `qc.ccx(${gate.controlQubit ?? 0}, ${gate.controlQubit2 ?? 1}, ${gate.qubit})`;
    case 'MEASURE':
      return `qc.measure(${gate.qubit}, ${gate.qubit})`;
    default:
      return `# Unknown gate: ${gate.type}`;
  }
}

export function CodeEditor() {
  const circuit = useCircuit();
  const code = useMemo(
    () => generateQiskitCode(circuit.numQubits, circuit.gates),
    [circuit.numQubits, circuit.gates]
  );

  const handleCopy = () => {
    navigator.clipboard.writeText(code);
  };

  return (
    <div className="code-editor">
      <div className="code-actions">
        <button onClick={handleCopy} className="copy-btn" title="Copy to clipboard">
          ðŸ“‹ Copy
        </button>
      </div>
      <pre className="code-content">
        <code>{code}</code>
      </pre>
    </div>
  );
}
